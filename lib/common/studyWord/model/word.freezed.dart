// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'word.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

WordModel _$WordModelFromJson(Map<String, dynamic> json) {
  return _WordModel.fromJson(json);
}

/// @nodoc
mixin _$WordModel {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get explainCN => throw _privateConstructorUsedError;
  String get UKSymbol => throw _privateConstructorUsedError;
  String get USSymbol => throw _privateConstructorUsedError;
  String get USAudio => throw _privateConstructorUsedError;
  String get UKAudio => throw _privateConstructorUsedError;
  String get type => throw _privateConstructorUsedError;
  String get sentence => throw _privateConstructorUsedError;
  String get sentenceCN => throw _privateConstructorUsedError;
  String get sentenceAudio => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $WordModelCopyWith<WordModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WordModelCopyWith<$Res> {
  factory $WordModelCopyWith(WordModel value, $Res Function(WordModel) then) =
      _$WordModelCopyWithImpl<$Res, WordModel>;
  @useResult
  $Res call(
      {String id,
      String name,
      String explainCN,
      String UKSymbol,
      String USSymbol,
      String USAudio,
      String UKAudio,
      String type,
      String sentence,
      String sentenceCN,
      String sentenceAudio});
}

/// @nodoc
class _$WordModelCopyWithImpl<$Res, $Val extends WordModel>
    implements $WordModelCopyWith<$Res> {
  _$WordModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? explainCN = null,
    Object? UKSymbol = null,
    Object? USSymbol = null,
    Object? USAudio = null,
    Object? UKAudio = null,
    Object? type = null,
    Object? sentence = null,
    Object? sentenceCN = null,
    Object? sentenceAudio = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      explainCN: null == explainCN
          ? _value.explainCN
          : explainCN // ignore: cast_nullable_to_non_nullable
              as String,
      UKSymbol: null == UKSymbol
          ? _value.UKSymbol
          : UKSymbol // ignore: cast_nullable_to_non_nullable
              as String,
      USSymbol: null == USSymbol
          ? _value.USSymbol
          : USSymbol // ignore: cast_nullable_to_non_nullable
              as String,
      USAudio: null == USAudio
          ? _value.USAudio
          : USAudio // ignore: cast_nullable_to_non_nullable
              as String,
      UKAudio: null == UKAudio
          ? _value.UKAudio
          : UKAudio // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      sentence: null == sentence
          ? _value.sentence
          : sentence // ignore: cast_nullable_to_non_nullable
              as String,
      sentenceCN: null == sentenceCN
          ? _value.sentenceCN
          : sentenceCN // ignore: cast_nullable_to_non_nullable
              as String,
      sentenceAudio: null == sentenceAudio
          ? _value.sentenceAudio
          : sentenceAudio // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WordModelImplCopyWith<$Res>
    implements $WordModelCopyWith<$Res> {
  factory _$$WordModelImplCopyWith(
          _$WordModelImpl value, $Res Function(_$WordModelImpl) then) =
      __$$WordModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String explainCN,
      String UKSymbol,
      String USSymbol,
      String USAudio,
      String UKAudio,
      String type,
      String sentence,
      String sentenceCN,
      String sentenceAudio});
}

/// @nodoc
class __$$WordModelImplCopyWithImpl<$Res>
    extends _$WordModelCopyWithImpl<$Res, _$WordModelImpl>
    implements _$$WordModelImplCopyWith<$Res> {
  __$$WordModelImplCopyWithImpl(
      _$WordModelImpl _value, $Res Function(_$WordModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? explainCN = null,
    Object? UKSymbol = null,
    Object? USSymbol = null,
    Object? USAudio = null,
    Object? UKAudio = null,
    Object? type = null,
    Object? sentence = null,
    Object? sentenceCN = null,
    Object? sentenceAudio = null,
  }) {
    return _then(_$WordModelImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      explainCN: null == explainCN
          ? _value.explainCN
          : explainCN // ignore: cast_nullable_to_non_nullable
              as String,
      UKSymbol: null == UKSymbol
          ? _value.UKSymbol
          : UKSymbol // ignore: cast_nullable_to_non_nullable
              as String,
      USSymbol: null == USSymbol
          ? _value.USSymbol
          : USSymbol // ignore: cast_nullable_to_non_nullable
              as String,
      USAudio: null == USAudio
          ? _value.USAudio
          : USAudio // ignore: cast_nullable_to_non_nullable
              as String,
      UKAudio: null == UKAudio
          ? _value.UKAudio
          : UKAudio // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      sentence: null == sentence
          ? _value.sentence
          : sentence // ignore: cast_nullable_to_non_nullable
              as String,
      sentenceCN: null == sentenceCN
          ? _value.sentenceCN
          : sentenceCN // ignore: cast_nullable_to_non_nullable
              as String,
      sentenceAudio: null == sentenceAudio
          ? _value.sentenceAudio
          : sentenceAudio // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$WordModelImpl with DiagnosticableTreeMixin implements _WordModel {
  const _$WordModelImpl(
      {required this.id,
      required this.name,
      required this.explainCN,
      required this.UKSymbol,
      required this.USSymbol,
      required this.USAudio,
      required this.UKAudio,
      required this.type,
      required this.sentence,
      required this.sentenceCN,
      required this.sentenceAudio});

  factory _$WordModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$WordModelImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String explainCN;
  @override
  final String UKSymbol;
  @override
  final String USSymbol;
  @override
  final String USAudio;
  @override
  final String UKAudio;
  @override
  final String type;
  @override
  final String sentence;
  @override
  final String sentenceCN;
  @override
  final String sentenceAudio;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'WordModel(id: $id, name: $name, explainCN: $explainCN, UKSymbol: $UKSymbol, USSymbol: $USSymbol, USAudio: $USAudio, UKAudio: $UKAudio, type: $type, sentence: $sentence, sentenceCN: $sentenceCN, sentenceAudio: $sentenceAudio)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'WordModel'))
      ..add(DiagnosticsProperty('id', id))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('explainCN', explainCN))
      ..add(DiagnosticsProperty('UKSymbol', UKSymbol))
      ..add(DiagnosticsProperty('USSymbol', USSymbol))
      ..add(DiagnosticsProperty('USAudio', USAudio))
      ..add(DiagnosticsProperty('UKAudio', UKAudio))
      ..add(DiagnosticsProperty('type', type))
      ..add(DiagnosticsProperty('sentence', sentence))
      ..add(DiagnosticsProperty('sentenceCN', sentenceCN))
      ..add(DiagnosticsProperty('sentenceAudio', sentenceAudio));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WordModelImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.explainCN, explainCN) ||
                other.explainCN == explainCN) &&
            (identical(other.UKSymbol, UKSymbol) ||
                other.UKSymbol == UKSymbol) &&
            (identical(other.USSymbol, USSymbol) ||
                other.USSymbol == USSymbol) &&
            (identical(other.USAudio, USAudio) || other.USAudio == USAudio) &&
            (identical(other.UKAudio, UKAudio) || other.UKAudio == UKAudio) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.sentence, sentence) ||
                other.sentence == sentence) &&
            (identical(other.sentenceCN, sentenceCN) ||
                other.sentenceCN == sentenceCN) &&
            (identical(other.sentenceAudio, sentenceAudio) ||
                other.sentenceAudio == sentenceAudio));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, explainCN, UKSymbol,
      USSymbol, USAudio, UKAudio, type, sentence, sentenceCN, sentenceAudio);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WordModelImplCopyWith<_$WordModelImpl> get copyWith =>
      __$$WordModelImplCopyWithImpl<_$WordModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$WordModelImplToJson(
      this,
    );
  }
}

abstract class _WordModel implements WordModel {
  const factory _WordModel(
      {required final String id,
      required final String name,
      required final String explainCN,
      required final String UKSymbol,
      required final String USSymbol,
      required final String USAudio,
      required final String UKAudio,
      required final String type,
      required final String sentence,
      required final String sentenceCN,
      required final String sentenceAudio}) = _$WordModelImpl;

  factory _WordModel.fromJson(Map<String, dynamic> json) =
      _$WordModelImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String get explainCN;
  @override
  String get UKSymbol;
  @override
  String get USSymbol;
  @override
  String get USAudio;
  @override
  String get UKAudio;
  @override
  String get type;
  @override
  String get sentence;
  @override
  String get sentenceCN;
  @override
  String get sentenceAudio;
  @override
  @JsonKey(ignore: true)
  _$$WordModelImplCopyWith<_$WordModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

TodayReviewWord _$TodayReviewWordFromJson(Map<String, dynamic> json) {
  return _TodayReviewWord.fromJson(json);
}

/// @nodoc
mixin _$TodayReviewWord {
  WordModel get word => throw _privateConstructorUsedError;
  int get studyTimes => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TodayReviewWordCopyWith<TodayReviewWord> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TodayReviewWordCopyWith<$Res> {
  factory $TodayReviewWordCopyWith(
          TodayReviewWord value, $Res Function(TodayReviewWord) then) =
      _$TodayReviewWordCopyWithImpl<$Res, TodayReviewWord>;
  @useResult
  $Res call({WordModel word, int studyTimes});

  $WordModelCopyWith<$Res> get word;
}

/// @nodoc
class _$TodayReviewWordCopyWithImpl<$Res, $Val extends TodayReviewWord>
    implements $TodayReviewWordCopyWith<$Res> {
  _$TodayReviewWordCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? word = null,
    Object? studyTimes = null,
  }) {
    return _then(_value.copyWith(
      word: null == word
          ? _value.word
          : word // ignore: cast_nullable_to_non_nullable
              as WordModel,
      studyTimes: null == studyTimes
          ? _value.studyTimes
          : studyTimes // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $WordModelCopyWith<$Res> get word {
    return $WordModelCopyWith<$Res>(_value.word, (value) {
      return _then(_value.copyWith(word: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$TodayReviewWordImplCopyWith<$Res>
    implements $TodayReviewWordCopyWith<$Res> {
  factory _$$TodayReviewWordImplCopyWith(_$TodayReviewWordImpl value,
          $Res Function(_$TodayReviewWordImpl) then) =
      __$$TodayReviewWordImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({WordModel word, int studyTimes});

  @override
  $WordModelCopyWith<$Res> get word;
}

/// @nodoc
class __$$TodayReviewWordImplCopyWithImpl<$Res>
    extends _$TodayReviewWordCopyWithImpl<$Res, _$TodayReviewWordImpl>
    implements _$$TodayReviewWordImplCopyWith<$Res> {
  __$$TodayReviewWordImplCopyWithImpl(
      _$TodayReviewWordImpl _value, $Res Function(_$TodayReviewWordImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? word = null,
    Object? studyTimes = null,
  }) {
    return _then(_$TodayReviewWordImpl(
      word: null == word
          ? _value.word
          : word // ignore: cast_nullable_to_non_nullable
              as WordModel,
      studyTimes: null == studyTimes
          ? _value.studyTimes
          : studyTimes // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TodayReviewWordImpl
    with DiagnosticableTreeMixin
    implements _TodayReviewWord {
  const _$TodayReviewWordImpl({required this.word, required this.studyTimes});

  factory _$TodayReviewWordImpl.fromJson(Map<String, dynamic> json) =>
      _$$TodayReviewWordImplFromJson(json);

  @override
  final WordModel word;
  @override
  final int studyTimes;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TodayReviewWord(word: $word, studyTimes: $studyTimes)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TodayReviewWord'))
      ..add(DiagnosticsProperty('word', word))
      ..add(DiagnosticsProperty('studyTimes', studyTimes));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TodayReviewWordImpl &&
            (identical(other.word, word) || other.word == word) &&
            (identical(other.studyTimes, studyTimes) ||
                other.studyTimes == studyTimes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, word, studyTimes);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TodayReviewWordImplCopyWith<_$TodayReviewWordImpl> get copyWith =>
      __$$TodayReviewWordImplCopyWithImpl<_$TodayReviewWordImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TodayReviewWordImplToJson(
      this,
    );
  }
}

abstract class _TodayReviewWord implements TodayReviewWord {
  const factory _TodayReviewWord(
      {required final WordModel word,
      required final int studyTimes}) = _$TodayReviewWordImpl;

  factory _TodayReviewWord.fromJson(Map<String, dynamic> json) =
      _$TodayReviewWordImpl.fromJson;

  @override
  WordModel get word;
  @override
  int get studyTimes;
  @override
  @JsonKey(ignore: true)
  _$$TodayReviewWordImplCopyWith<_$TodayReviewWordImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

UploadWordItem _$UploadWordItemFromJson(Map<String, dynamic> json) {
  return _UploadWordItem.fromJson(json);
}

/// @nodoc
mixin _$UploadWordItem {
  String get wordId => throw _privateConstructorUsedError;
  String get nextReviewTime => throw _privateConstructorUsedError;
  int? get studyTimes => throw _privateConstructorUsedError;
  bool? get isSimple => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UploadWordItemCopyWith<UploadWordItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UploadWordItemCopyWith<$Res> {
  factory $UploadWordItemCopyWith(
          UploadWordItem value, $Res Function(UploadWordItem) then) =
      _$UploadWordItemCopyWithImpl<$Res, UploadWordItem>;
  @useResult
  $Res call(
      {String wordId, String nextReviewTime, int? studyTimes, bool? isSimple});
}

/// @nodoc
class _$UploadWordItemCopyWithImpl<$Res, $Val extends UploadWordItem>
    implements $UploadWordItemCopyWith<$Res> {
  _$UploadWordItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? wordId = null,
    Object? nextReviewTime = null,
    Object? studyTimes = freezed,
    Object? isSimple = freezed,
  }) {
    return _then(_value.copyWith(
      wordId: null == wordId
          ? _value.wordId
          : wordId // ignore: cast_nullable_to_non_nullable
              as String,
      nextReviewTime: null == nextReviewTime
          ? _value.nextReviewTime
          : nextReviewTime // ignore: cast_nullable_to_non_nullable
              as String,
      studyTimes: freezed == studyTimes
          ? _value.studyTimes
          : studyTimes // ignore: cast_nullable_to_non_nullable
              as int?,
      isSimple: freezed == isSimple
          ? _value.isSimple
          : isSimple // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UploadWordItemImplCopyWith<$Res>
    implements $UploadWordItemCopyWith<$Res> {
  factory _$$UploadWordItemImplCopyWith(_$UploadWordItemImpl value,
          $Res Function(_$UploadWordItemImpl) then) =
      __$$UploadWordItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String wordId, String nextReviewTime, int? studyTimes, bool? isSimple});
}

/// @nodoc
class __$$UploadWordItemImplCopyWithImpl<$Res>
    extends _$UploadWordItemCopyWithImpl<$Res, _$UploadWordItemImpl>
    implements _$$UploadWordItemImplCopyWith<$Res> {
  __$$UploadWordItemImplCopyWithImpl(
      _$UploadWordItemImpl _value, $Res Function(_$UploadWordItemImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? wordId = null,
    Object? nextReviewTime = null,
    Object? studyTimes = freezed,
    Object? isSimple = freezed,
  }) {
    return _then(_$UploadWordItemImpl(
      wordId: null == wordId
          ? _value.wordId
          : wordId // ignore: cast_nullable_to_non_nullable
              as String,
      nextReviewTime: null == nextReviewTime
          ? _value.nextReviewTime
          : nextReviewTime // ignore: cast_nullable_to_non_nullable
              as String,
      studyTimes: freezed == studyTimes
          ? _value.studyTimes
          : studyTimes // ignore: cast_nullable_to_non_nullable
              as int?,
      isSimple: freezed == isSimple
          ? _value.isSimple
          : isSimple // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UploadWordItemImpl
    with DiagnosticableTreeMixin
    implements _UploadWordItem {
  const _$UploadWordItemImpl(
      {required this.wordId,
      required this.nextReviewTime,
      this.studyTimes,
      this.isSimple});

  factory _$UploadWordItemImpl.fromJson(Map<String, dynamic> json) =>
      _$$UploadWordItemImplFromJson(json);

  @override
  final String wordId;
  @override
  final String nextReviewTime;
  @override
  final int? studyTimes;
  @override
  final bool? isSimple;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'UploadWordItem(wordId: $wordId, nextReviewTime: $nextReviewTime, studyTimes: $studyTimes, isSimple: $isSimple)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'UploadWordItem'))
      ..add(DiagnosticsProperty('wordId', wordId))
      ..add(DiagnosticsProperty('nextReviewTime', nextReviewTime))
      ..add(DiagnosticsProperty('studyTimes', studyTimes))
      ..add(DiagnosticsProperty('isSimple', isSimple));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UploadWordItemImpl &&
            (identical(other.wordId, wordId) || other.wordId == wordId) &&
            (identical(other.nextReviewTime, nextReviewTime) ||
                other.nextReviewTime == nextReviewTime) &&
            (identical(other.studyTimes, studyTimes) ||
                other.studyTimes == studyTimes) &&
            (identical(other.isSimple, isSimple) ||
                other.isSimple == isSimple));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, wordId, nextReviewTime, studyTimes, isSimple);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UploadWordItemImplCopyWith<_$UploadWordItemImpl> get copyWith =>
      __$$UploadWordItemImplCopyWithImpl<_$UploadWordItemImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$UploadWordItemImplToJson(
      this,
    );
  }
}

abstract class _UploadWordItem implements UploadWordItem {
  const factory _UploadWordItem(
      {required final String wordId,
      required final String nextReviewTime,
      final int? studyTimes,
      final bool? isSimple}) = _$UploadWordItemImpl;

  factory _UploadWordItem.fromJson(Map<String, dynamic> json) =
      _$UploadWordItemImpl.fromJson;

  @override
  String get wordId;
  @override
  String get nextReviewTime;
  @override
  int? get studyTimes;
  @override
  bool? get isSimple;
  @override
  @JsonKey(ignore: true)
  _$$UploadWordItemImplCopyWith<_$UploadWordItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

SummaryWordItem _$SummaryWordItemFromJson(Map<String, dynamic> json) {
  return _SummaryWordItem.fromJson(json);
}

/// @nodoc
mixin _$SummaryWordItem {
  String get name => throw _privateConstructorUsedError;
  String get type => throw _privateConstructorUsedError;
  String get USAudio => throw _privateConstructorUsedError;
  String get explainCN => throw _privateConstructorUsedError;
  bool? get isKnow => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SummaryWordItemCopyWith<SummaryWordItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SummaryWordItemCopyWith<$Res> {
  factory $SummaryWordItemCopyWith(
          SummaryWordItem value, $Res Function(SummaryWordItem) then) =
      _$SummaryWordItemCopyWithImpl<$Res, SummaryWordItem>;
  @useResult
  $Res call(
      {String name,
      String type,
      String USAudio,
      String explainCN,
      bool? isKnow});
}

/// @nodoc
class _$SummaryWordItemCopyWithImpl<$Res, $Val extends SummaryWordItem>
    implements $SummaryWordItemCopyWith<$Res> {
  _$SummaryWordItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? type = null,
    Object? USAudio = null,
    Object? explainCN = null,
    Object? isKnow = freezed,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      USAudio: null == USAudio
          ? _value.USAudio
          : USAudio // ignore: cast_nullable_to_non_nullable
              as String,
      explainCN: null == explainCN
          ? _value.explainCN
          : explainCN // ignore: cast_nullable_to_non_nullable
              as String,
      isKnow: freezed == isKnow
          ? _value.isKnow
          : isKnow // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SummaryWordItemImplCopyWith<$Res>
    implements $SummaryWordItemCopyWith<$Res> {
  factory _$$SummaryWordItemImplCopyWith(_$SummaryWordItemImpl value,
          $Res Function(_$SummaryWordItemImpl) then) =
      __$$SummaryWordItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      String type,
      String USAudio,
      String explainCN,
      bool? isKnow});
}

/// @nodoc
class __$$SummaryWordItemImplCopyWithImpl<$Res>
    extends _$SummaryWordItemCopyWithImpl<$Res, _$SummaryWordItemImpl>
    implements _$$SummaryWordItemImplCopyWith<$Res> {
  __$$SummaryWordItemImplCopyWithImpl(
      _$SummaryWordItemImpl _value, $Res Function(_$SummaryWordItemImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? type = null,
    Object? USAudio = null,
    Object? explainCN = null,
    Object? isKnow = freezed,
  }) {
    return _then(_$SummaryWordItemImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      USAudio: null == USAudio
          ? _value.USAudio
          : USAudio // ignore: cast_nullable_to_non_nullable
              as String,
      explainCN: null == explainCN
          ? _value.explainCN
          : explainCN // ignore: cast_nullable_to_non_nullable
              as String,
      isKnow: freezed == isKnow
          ? _value.isKnow
          : isKnow // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SummaryWordItemImpl
    with DiagnosticableTreeMixin
    implements _SummaryWordItem {
  const _$SummaryWordItemImpl(
      {required this.name,
      required this.type,
      required this.USAudio,
      required this.explainCN,
      this.isKnow});

  factory _$SummaryWordItemImpl.fromJson(Map<String, dynamic> json) =>
      _$$SummaryWordItemImplFromJson(json);

  @override
  final String name;
  @override
  final String type;
  @override
  final String USAudio;
  @override
  final String explainCN;
  @override
  final bool? isKnow;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SummaryWordItem(name: $name, type: $type, USAudio: $USAudio, explainCN: $explainCN, isKnow: $isKnow)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SummaryWordItem'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('type', type))
      ..add(DiagnosticsProperty('USAudio', USAudio))
      ..add(DiagnosticsProperty('explainCN', explainCN))
      ..add(DiagnosticsProperty('isKnow', isKnow));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SummaryWordItemImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.USAudio, USAudio) || other.USAudio == USAudio) &&
            (identical(other.explainCN, explainCN) ||
                other.explainCN == explainCN) &&
            (identical(other.isKnow, isKnow) || other.isKnow == isKnow));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, name, type, USAudio, explainCN, isKnow);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SummaryWordItemImplCopyWith<_$SummaryWordItemImpl> get copyWith =>
      __$$SummaryWordItemImplCopyWithImpl<_$SummaryWordItemImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SummaryWordItemImplToJson(
      this,
    );
  }
}

abstract class _SummaryWordItem implements SummaryWordItem {
  const factory _SummaryWordItem(
      {required final String name,
      required final String type,
      required final String USAudio,
      required final String explainCN,
      final bool? isKnow}) = _$SummaryWordItemImpl;

  factory _SummaryWordItem.fromJson(Map<String, dynamic> json) =
      _$SummaryWordItemImpl.fromJson;

  @override
  String get name;
  @override
  String get type;
  @override
  String get USAudio;
  @override
  String get explainCN;
  @override
  bool? get isKnow;
  @override
  @JsonKey(ignore: true)
  _$$SummaryWordItemImplCopyWith<_$SummaryWordItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

StudyWordRes _$StudyWordResFromJson(Map<String, dynamic> json) {
  return _StudyWordRes.fromJson(json);
}

/// @nodoc
mixin _$StudyWordRes {
  List<dynamic> get data => throw _privateConstructorUsedError;
  int get type => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $StudyWordResCopyWith<StudyWordRes> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StudyWordResCopyWith<$Res> {
  factory $StudyWordResCopyWith(
          StudyWordRes value, $Res Function(StudyWordRes) then) =
      _$StudyWordResCopyWithImpl<$Res, StudyWordRes>;
  @useResult
  $Res call({List<dynamic> data, int type});
}

/// @nodoc
class _$StudyWordResCopyWithImpl<$Res, $Val extends StudyWordRes>
    implements $StudyWordResCopyWith<$Res> {
  _$StudyWordResCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<dynamic>,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$StudyWordResImplCopyWith<$Res>
    implements $StudyWordResCopyWith<$Res> {
  factory _$$StudyWordResImplCopyWith(
          _$StudyWordResImpl value, $Res Function(_$StudyWordResImpl) then) =
      __$$StudyWordResImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<dynamic> data, int type});
}

/// @nodoc
class __$$StudyWordResImplCopyWithImpl<$Res>
    extends _$StudyWordResCopyWithImpl<$Res, _$StudyWordResImpl>
    implements _$$StudyWordResImplCopyWith<$Res> {
  __$$StudyWordResImplCopyWithImpl(
      _$StudyWordResImpl _value, $Res Function(_$StudyWordResImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? type = null,
  }) {
    return _then(_$StudyWordResImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<dynamic>,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$StudyWordResImpl with DiagnosticableTreeMixin implements _StudyWordRes {
  const _$StudyWordResImpl(
      {required final List<dynamic> data, required this.type})
      : _data = data;

  factory _$StudyWordResImpl.fromJson(Map<String, dynamic> json) =>
      _$$StudyWordResImplFromJson(json);

  final List<dynamic> _data;
  @override
  List<dynamic> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  final int type;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'StudyWordRes(data: $data, type: $type)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'StudyWordRes'))
      ..add(DiagnosticsProperty('data', data))
      ..add(DiagnosticsProperty('type', type));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StudyWordResImpl &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_data), type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StudyWordResImplCopyWith<_$StudyWordResImpl> get copyWith =>
      __$$StudyWordResImplCopyWithImpl<_$StudyWordResImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$StudyWordResImplToJson(
      this,
    );
  }
}

abstract class _StudyWordRes implements StudyWordRes {
  const factory _StudyWordRes(
      {required final List<dynamic> data,
      required final int type}) = _$StudyWordResImpl;

  factory _StudyWordRes.fromJson(Map<String, dynamic> json) =
      _$StudyWordResImpl.fromJson;

  @override
  List<dynamic> get data;
  @override
  int get type;
  @override
  @JsonKey(ignore: true)
  _$$StudyWordResImplCopyWith<_$StudyWordResImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

NewWordRes _$NewWordResFromJson(Map<String, dynamic> json) {
  return _NewWordRes.fromJson(json);
}

/// @nodoc
mixin _$NewWordRes {
  List<WordModel> get data => throw _privateConstructorUsedError;
  int get type => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NewWordResCopyWith<NewWordRes> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NewWordResCopyWith<$Res> {
  factory $NewWordResCopyWith(
          NewWordRes value, $Res Function(NewWordRes) then) =
      _$NewWordResCopyWithImpl<$Res, NewWordRes>;
  @useResult
  $Res call({List<WordModel> data, int type});
}

/// @nodoc
class _$NewWordResCopyWithImpl<$Res, $Val extends NewWordRes>
    implements $NewWordResCopyWith<$Res> {
  _$NewWordResCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<WordModel>,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NewWordResImplCopyWith<$Res>
    implements $NewWordResCopyWith<$Res> {
  factory _$$NewWordResImplCopyWith(
          _$NewWordResImpl value, $Res Function(_$NewWordResImpl) then) =
      __$$NewWordResImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<WordModel> data, int type});
}

/// @nodoc
class __$$NewWordResImplCopyWithImpl<$Res>
    extends _$NewWordResCopyWithImpl<$Res, _$NewWordResImpl>
    implements _$$NewWordResImplCopyWith<$Res> {
  __$$NewWordResImplCopyWithImpl(
      _$NewWordResImpl _value, $Res Function(_$NewWordResImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? type = null,
  }) {
    return _then(_$NewWordResImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<WordModel>,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NewWordResImpl with DiagnosticableTreeMixin implements _NewWordRes {
  const _$NewWordResImpl(
      {required final List<WordModel> data, required this.type})
      : _data = data;

  factory _$NewWordResImpl.fromJson(Map<String, dynamic> json) =>
      _$$NewWordResImplFromJson(json);

  final List<WordModel> _data;
  @override
  List<WordModel> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  final int type;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'NewWordRes(data: $data, type: $type)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'NewWordRes'))
      ..add(DiagnosticsProperty('data', data))
      ..add(DiagnosticsProperty('type', type));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NewWordResImpl &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_data), type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NewWordResImplCopyWith<_$NewWordResImpl> get copyWith =>
      __$$NewWordResImplCopyWithImpl<_$NewWordResImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$NewWordResImplToJson(
      this,
    );
  }
}

abstract class _NewWordRes implements NewWordRes {
  const factory _NewWordRes(
      {required final List<WordModel> data,
      required final int type}) = _$NewWordResImpl;

  factory _NewWordRes.fromJson(Map<String, dynamic> json) =
      _$NewWordResImpl.fromJson;

  @override
  List<WordModel> get data;
  @override
  int get type;
  @override
  @JsonKey(ignore: true)
  _$$NewWordResImplCopyWith<_$NewWordResImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ReviewWordRes _$ReviewWordResFromJson(Map<String, dynamic> json) {
  return _ReviewWordRes.fromJson(json);
}

/// @nodoc
mixin _$ReviewWordRes {
  List<TodayReviewWord> get data => throw _privateConstructorUsedError;
  int get type => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ReviewWordResCopyWith<ReviewWordRes> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ReviewWordResCopyWith<$Res> {
  factory $ReviewWordResCopyWith(
          ReviewWordRes value, $Res Function(ReviewWordRes) then) =
      _$ReviewWordResCopyWithImpl<$Res, ReviewWordRes>;
  @useResult
  $Res call({List<TodayReviewWord> data, int type});
}

/// @nodoc
class _$ReviewWordResCopyWithImpl<$Res, $Val extends ReviewWordRes>
    implements $ReviewWordResCopyWith<$Res> {
  _$ReviewWordResCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<TodayReviewWord>,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ReviewWordResImplCopyWith<$Res>
    implements $ReviewWordResCopyWith<$Res> {
  factory _$$ReviewWordResImplCopyWith(
          _$ReviewWordResImpl value, $Res Function(_$ReviewWordResImpl) then) =
      __$$ReviewWordResImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<TodayReviewWord> data, int type});
}

/// @nodoc
class __$$ReviewWordResImplCopyWithImpl<$Res>
    extends _$ReviewWordResCopyWithImpl<$Res, _$ReviewWordResImpl>
    implements _$$ReviewWordResImplCopyWith<$Res> {
  __$$ReviewWordResImplCopyWithImpl(
      _$ReviewWordResImpl _value, $Res Function(_$ReviewWordResImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? type = null,
  }) {
    return _then(_$ReviewWordResImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<TodayReviewWord>,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ReviewWordResImpl
    with DiagnosticableTreeMixin
    implements _ReviewWordRes {
  const _$ReviewWordResImpl(
      {required final List<TodayReviewWord> data, required this.type})
      : _data = data;

  factory _$ReviewWordResImpl.fromJson(Map<String, dynamic> json) =>
      _$$ReviewWordResImplFromJson(json);

  final List<TodayReviewWord> _data;
  @override
  List<TodayReviewWord> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  final int type;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ReviewWordRes(data: $data, type: $type)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ReviewWordRes'))
      ..add(DiagnosticsProperty('data', data))
      ..add(DiagnosticsProperty('type', type));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ReviewWordResImpl &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_data), type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ReviewWordResImplCopyWith<_$ReviewWordResImpl> get copyWith =>
      __$$ReviewWordResImplCopyWithImpl<_$ReviewWordResImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ReviewWordResImplToJson(
      this,
    );
  }
}

abstract class _ReviewWordRes implements ReviewWordRes {
  const factory _ReviewWordRes(
      {required final List<TodayReviewWord> data,
      required final int type}) = _$ReviewWordResImpl;

  factory _ReviewWordRes.fromJson(Map<String, dynamic> json) =
      _$ReviewWordResImpl.fromJson;

  @override
  List<TodayReviewWord> get data;
  @override
  int get type;
  @override
  @JsonKey(ignore: true)
  _$$ReviewWordResImplCopyWith<_$ReviewWordResImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
